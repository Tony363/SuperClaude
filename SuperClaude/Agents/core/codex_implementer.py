"""
Codex-focused implementation persona.

Provides a lightweight strategist that optimises for rapid diff generation by
delegating to Codex-oriented heuristics instead of the full multi-persona stack.
"""

from __future__ import annotations

import datetime as _dt
import json
from pathlib import Path
from typing import Any

from ...APIClients.codex_cli import (
    CodexCLIClient,
    CodexCLIConfig,
    CodexCLIResult,
)
from ..heuristic_markdown import HeuristicMarkdownAgent


class CodexImplementer(HeuristicMarkdownAgent):
    """Lean persona that mirrors Codex-style rapid implementation workflows."""

    STRATEGIST_TIER = True
    default_extension = "py"

    QUICK_HINT_KEYWORDS = [
        "refactor",
        "rename",
        "cleanup",
        "lint",
        "docs",
        "typo",
        "comment",
        "minor",
        "small",
        "fast follow",
        "nit",
    ]

    def __init__(self, config: dict[str, Any]):
        defaults = {
            "name": "codex-implementer",
            "description": (
                "Generate concise, Codex-style implementation diffs with minimal orchestration "
                "overhead while preserving evidence guardrails."
            ),
            "category": "core-development",
            "tools": ["write", "multi-edit", "read"],
            "triggers": ["fast-codex", "quick"],
            "focus_areas": {
                "implementation": "Rapid iteration on localized code edits with evidence capture.",
                "guardrails": "Maintains requires_evidence while bypassing heavy persona stacks.",
            },
        }
        merged = {**defaults, **config}
        super().__init__(merged)
        cli_config = merged.get("codex_cli", {})
        config_obj = None
        if isinstance(cli_config, dict) and cli_config:
            config_obj = CodexCLIConfig(**cli_config)
        self._cli_client = CodexCLIClient(config_obj)

    def validate(self, context: dict[str, Any]) -> bool:
        """Prefer small or well-scoped implementation tasks."""
        task = str(context.get("task", "")).lower()
        if not task:
            return False

        keywords_hit = sum(1 for token in self.QUICK_HINT_KEYWORDS if token in task)
        if keywords_hit:
            return True

        # Allow fallback for explicit fast mode invocations even without keywords.
        return "fast-codex" in task or "fast codex" in task

    def execute(self, context: dict[str, Any]) -> dict[str, Any]:
        """Run heuristic synthesis and annotate the result for Codex telemetry."""
        result = super().execute(context)

        metadata = result.setdefault("metadata", {})
        metadata["execution_path"] = "codex"
        metadata["offline"] = metadata.get("offline", False)

        payload, cli_result = self._generate_codex_payload(context)
        codex_changes = (payload or {}).get("changes") or []

        if payload:
            metadata["codex"] = {
                "summary": payload.get("summary", "Generated by Codex"),
                "generated_at": _dt.datetime.utcnow().isoformat() + "Z",
                "model": payload.get("model"),
            }
            result["codex_suggestions"] = payload
            result.setdefault("notes", []).append(
                f"Codex summary: {payload.get('summary', 'No summary provided')}"
            )
        if cli_result:
            cli_meta = {
                "duration_s": round(cli_result.duration_s, 3),
                "returncode": cli_result.returncode,
                "stdout": cli_result.stdout,
                "stderr": cli_result.stderr,
            }
            metadata["codex_cli"] = cli_meta
            result["codex_cli"] = cli_meta
        if codex_changes:
            self._apply_codex_changes(result, codex_changes, payload)
        elif not payload:
            result.setdefault("warnings", []).append(
                "Codex CLI produced no actionable changes; inspect stdout for details."
            )

        quick_notes: list[str] = result.setdefault("notes", [])
        if (
            "Codex strategy: prioritize minimal diff with evidence attached."
            not in quick_notes
        ):
            quick_notes.append(
                "Codex strategy: prioritize minimal diff with evidence attached."
            )

        return result

    # ------------------------------------------------------------------ #
    # Codex integration helpers
    # ------------------------------------------------------------------ #

    def _generate_codex_payload(
        self,
        context: dict[str, Any],
    ) -> tuple[dict[str, Any] | None, CodexCLIResult | None]:
        """Invoke the Codex CLI and normalise its response."""

        prompt = self._build_codex_prompt(context)
        if not prompt:
            return None, None

        repo_root_str = context.get("repo_root") or context.get("base_path")
        workdir: Path | None = Path(repo_root_str) if repo_root_str else None

        cli_result = self._cli_client.run(prompt, workdir=workdir)
        payload = cli_result.payload or {}

        changes = self._normalise_changes(payload.get("changes"))
        if not changes:
            return None, cli_result

        return (
            {
                "summary": payload.get("summary", "Generated by Codex"),
                "changes": changes,
                "model": payload.get("model", "codex-cli"),
            },
            cli_result,
        )

    def _apply_codex_changes(
        self,
        result: dict[str, Any],
        changes: list[dict[str, Any]],
        payload: dict[str, Any] | None,
    ) -> None:
        """Promote Codex CLI changes into the agent result for execution."""

        summary = (payload or {}).get("summary") or "Codex CLI changes"
        result["proposed_changes"] = changes

        writes = [
            f"write {change.get('path')}" for change in changes if change.get("path")
        ]
        existing_actions = result.get("actions_taken") or []
        result["actions_taken"] = existing_actions + [
            action for action in writes if action not in existing_actions
        ]

        if not result.get("output"):
            result["output"] = summary

        # Clear plan-only warning when Codex produced concrete diffs.
        warnings = result.get("warnings") or []
        plan_warning = (
            "No concrete file or command changes detected; escalating to follow-up."
        )
        result["warnings"] = [w for w in warnings if w.strip() != plan_warning]

        result.pop("requires_followup", None)
        result["status"] = "executed"
        result["success"] = True

    def _build_codex_prompt(self, context: dict[str, Any]) -> str | None:
        task = str(context.get("task", "")).strip()
        if not task:
            return None

        retrieved_context = context.get("retrieved_context") or []
        snippets: list[str] = []
        for entry in retrieved_context[:3]:
            if isinstance(entry, dict):
                summary = entry.get("summary") or entry.get("content") or ""
                source = entry.get("path") or entry.get("source") or "context"
                if summary:
                    snippets.append(f"[{source}] {summary[:400]}")

        instructions = (
            "You are an AI pair-programmer operating inside the SuperClaude fast Codex flow. "
            'Respond with STRICT JSON matching the schema {"summary": str, "changes": ['
            '{"path": str, "content": str, "mode": "replace"|"append"}]}. '
            "All paths must be repository-relative and valid. Keep diffs minimal and self-contained."
        )

        parts = [instructions, "", "Task:", task]
        flags = context.get("flags") or []
        if flags:
            parts.append("Flags: " + ", ".join(flags))
        params = context.get("parameters") or {}
        if params:
            parts.append("Parameters: " + json.dumps(params))
        if snippets:
            parts.append("Context:")
            parts.extend(snippets)

        return "\n".join(parts)

    def _normalise_changes(self, raw_changes: Any) -> list[dict[str, Any]]:
        changes: list[dict[str, Any]] = []
        if not isinstance(raw_changes, list):
            return changes

        for item in raw_changes:
            if not isinstance(item, dict):
                continue
            path = item.get("path")
            content = item.get("content")
            if not path or not isinstance(path, str) or not isinstance(content, str):
                continue
            mode = item.get("mode", "replace")
            changes.append(
                {
                    "path": path,
                    "content": content,
                    "mode": mode if isinstance(mode, str) else "replace",
                }
            )
        return changes
